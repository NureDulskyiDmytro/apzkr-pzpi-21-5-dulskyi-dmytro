Міністерство освіти і науки України
Харківський національний університет радіоелектроніки

Факультет комп’ютерних наук

Кафедра програмної інженерії

КУРСОВА РОБОТА
ПОЯСНЮВАЛЬНА ЗАПИСКА
з навчальної дисципліни «Архітектура програмного забезпечення»
Тема роботи: Програмна система для автоматизації зберігання товарів у складських приміщеннях

Студент гр. ПЗПІ-21-5 	               __________________ Дульський Д. А.
              (підпис)
Керівник роботи			    ___________________ доц. Лещинський В.О.
                      (підпис)
         Роботу захищено «__»_________2024 р.
         з оцінкою _________________________

Комісія: 				    ___________________ доц. Лещинський В.О.
                                    (підпис)
          ___________________ доц. Лещинська І.О.
             (підпис)
          ___________________ ст.викл. Сокорчук І.П.
        (підпис)



Харків 2024 р.

Харківський національний університет радіоелектроніки
Факультет          комп’ютерних наук	Кафедра      програмної інженерії	 
Спеціальність                 121 – Інженерія програмного забезпечення	  
Курс	3	Семестр	6		 Навчальна дисципліна               Архітектура програмного забезпечення	 

ЗАВДАННЯ
НА КУРСОВУ РОБОТУ СТУДЕНТОВІ


  	Дульському Дмитру Андрійовичу	
1. Тема	роботи:	«Програмна система для автоматизації зберігання товарів у складських приміщеннях»				                                  
2. Термін узгодження завдання курсової роботи « 31  »  березня	2024 р.
3. Термін здачі студентом закінченої роботи «  20 » червня	 2024 р.
4. Вихідні дані до проекту (роботи): створення нових облікових записів користувачів, управління даними про товари з боку адміністратора (створення, перегляд, оновлення, видалення), організація розміщення товарів, бронювання товарів, збір та оцінка статистики товарів, відстеження контейнерів. Для розробки використовується програмне забезпечення Windows, СУБД PostgreSQL, WebStorm, Android Studio та IntelliJ IDEA.
5. Зміст пояснювальної записки (перелік питань, що належить розробити) вступ, постановка задачі, розробка програмного проекту, структура бази даних, кодування програмного проекту, опис розробленої програмної системи, висновки, список використаної літератури, додатки.
6. Перелік графічного матеріалу (з точним зазначенням обов’язкових креслень) діаграма прецедентів, діаграма розгортання, ER-модель даних, діаграма компонентів, діаграма станів.                                                                              
КАЛЕНДАРНИЙ ПЛАН


№

Назва етапів курсової роботи
Термін виконання
етапів роботи

Примітка
1
Функціональна специфікація програмного проекту
31.03.24

виконано
2
Проектування програмного проекту
30.04.24

виконано
3
Кодування програмного проекту
20.05.24
виконано
4
Оформлення пояснювальної записки
31.05.24

виконано
5
Захист курсової роботи
08.06.24



	Дата видачі завдання  «25» березня 2024 р.


	Керівник           _____________             доц. Лещинський  В.О.
			              (підпис)

	Завдання  прийняв до виконання 
	ст. гр. ПЗПІ-21-5                              _____________         Дульський Д. А.

РЕФЕРАТ


     Пояснювальна записка: 61 с., 36 рис., 11 джерел, 5 додатків.
     АВТОМАТИЗАЦІЯ, АДМІНІСТРАТОР, АНАЛІЗ, БАЗА ДАНИХ, БІЗНЕС ЛОГІКА, КОРИСТУВАЧ, МОНІТОРИНГ, СПІВРОБІТНИК, ANDROID STUDIO, CSS,  JAVA, JAVASCRIPT, HTML, POSTGRESQL, SPRING.
     Метою даного дослідження є розробка програмного забезпечення для автоматизації зберігання товарів на складах. Метою проекту є полегшення складських операцій, таких як замовлення складських приміщень завядки інтернету, обробка цих замовлень, відстеження того, де зберігаються товари і як довго вони зберігаються, моніторинг і контроль температури і вологості контейнерів, а також проведення аналізу товарів для розуміння попиту на різні типи і розміри контейнерів. Систему потрібно розробити такою, де серверна частина системи буде створена з використанням фреймворку Spring на Java, для зберігання даних використовувалася б база даних PostgreSQL, клієнтська частина була б створена з використанням технологій JavaScript та CSS, а мобільний додаток був би розроблений з використанням середовища розробки Android Studio на Java.











ЗМІСТ




Вступ 	6
1 Аналіз предметної галузі	7
1.1 Аналіз конкуренції	7
1.2 Бізнес-цілі та критерії успіху	7
1.3 Потреби клієнта або ринку	8
1.4 Бізнес-ризики	8
2 Постановка задачі	9
2.1 Основний функціонал програмної системи	9
2.2 Припущення та залежності	9
2.3 Обмеження та винятки	10
2.4 Релізи	10
3 Архітектура програмної системи та її програмна реалізація	12
3.1 Проектування серверної частини	12
3.2 Проектування web-додатку	16
3.3 Проектування мобільного додатку	18
4 Опис розробленої програмної системи	21
4.1 Інтерфейс web-застосунку	21
4.2 Інтерфейс мобільного застосунку	28
Висновки	36
Перелік джерел посилання	37
Додаток А Діаграма станів веб-додатку	38
Додаток Б Код програми веб-додатку	39
Додаток В Діаграма прецедентів мобільного додатку	42
Додаток Г Код програми мобільного додатку	43
Додаток Д Плагіат	46
ВСТУП
    
    
     Використання інформаційних систем для управління запасами товару сьогодні – це не виняток, і не примха багатіїв, а радше необхідність. Без ІТ ефективна діяльність просто неможлива. Це стосується майже всіх учасників ринку, незалежно від їхнього становища та цілей на ринку. Малі та середні підприємства, а також великі компанії в наш час потребують програмного забезпечення, яке б спростило їхню роботу та підвищило ефективність праці. Автоматизоване управління складськими приміщеннями дозволить їм будувати ефективні відносини з клієнтами, значно підвищувати операційну ефективність і контролювати діяльність в режимі реального часу, і все це в найефективнішій мірі.
     Smart Storage – це практичні і необхідні рішення. Додаток дозволяє керувати товарами, зокрема перевіряти температуру та вологість контейнерів, обробляти та бронювати замовлення клієнтів, здійснювати пошук на складах та отримувати статистику замовлень. Статистика замовлень дозволяє аналізувати ваші товари, наприклад, популярні товари та довгий або короткий термін зберігання.
     Джерелом доходу є компанія, якій належить магазин. Монетизація базується на платній реєстрації сервісу в компанії.
     Оскільки інтелектуальний склад - це унікальна послуга, яка дозволяє управляти товарами в будь-якій точці світу за допомогою інтернет-з'єднання, ця система має великий потенціал для виходу на світовий ринок.


1 АНАЛІЗ ПРЕДМЕТНОЇ ГАЛУЗІ
     1.1 Аналіз конкуренції
     
     
     Основним конкурентом застосунку є «ТОВ ЮСАП СІСТЕМ». Ряд «фішок» компанії [1]: 
* управління знижками;
* контроль цін – можливість відстежувати та регулювати ціни на товари;
* фінансовий облік – ведення обліку фінансових операцій компанії;
* управління боргами – контроль та регулювання заборгованостей;
* інвентаризація – облік та управління запасами товарів;
* пошук/фільтр – зручні інструменти для пошуку та фільтрації даних;
* управління постачанням – координація процесів постачання товарів;
* відносини з постачальниками – підтримка та управління взаємовідносинами з постачальниками;
* резервування товарів – можливість резервування товарів для клієнтів;
* зберігання адрес – зберігання та управління адресами клієнтів та постачальників.
     
     
     1.2 Бізнес-цілі та критерії успіху
     
     
     Бізнес-цілі:
* міжнародний ринок;
* зробити систему максимально комфортною; 
* підтримка стабільного зростання прибутку;
* партнери для надання послуг;
* зібрати команду для роботи над системою.
     Критерії успіху:
* застосунок стає дедалі популярнішим, особливо серед середніх та великих підприємств;
* залучення інвесторів.
     
     
      1.3 Потреби клієнта або ринку
     
     
     З точки зору клієнта, це буде швидкий і зручний сервіс для обробки замовлень та безпечного зберігання товарів. Доступ до каси можливий з будь-якої точки світу, де є інтернет-зв'язок.
     	Цей сервіс користується високим попитом на ринку, оскільки він має всі необхідні функції для його використання і має найпростіший, практичний та інтуїтивно зрозумілий інтерфейс.
     
     
     1.4 Бізнес-ризики
     
     
     Основні бізнес-ризики проекту:
* наявність та популярність аналогів від конкурентів;
* синхронізація мобільної версії застосунку та браузерної
* потенційна проблема непопулярності;
* дефектні деталі обладнання.
     
     
     

2 ПОСТАНОВКА ЗАДАЧІ
     2.1 Основний функціонал програмної системи
     
     
     Комп'ютерна системи, призначена для автоматизації зберігання товарів на складах, повинна виконувати наступні функції
* реєстрація та аутентифікація користувачів;
* змінювати інформацію про профіль користувачем;
* блокування та розблокування користувачів адміністраторами;
* збереження права власності;
* обробка замовлень співробітниками;
* контроль температури і вологості в контейнері;
* статистика та аналіз продуктів;
* керування даними користувачів адміністраторами (CRUD).
     
     
     2.2 Припущення та залежності
     
     
     	Для того, щоб всі компоненти проекту працювали добре, застосовуються наступні припущення та залежності
* для використання програмної системи проекту необхідне серверне програмне забезпечення, програмне забезпечення бази даних, клієнтське програмне забезпечення та мобільне програмне забезпечення;
* звернення до постачальника програмного забезпечення;
* система потребує відділ технічної підтримки клієнтів та менеджмент.
* звернення до спеціалістів з технічної підтримки;
* деякі апаратні збої можуть призвести до втрати великої кількості важливих даних.
     2.3 Обмеження та винятки
     	
     
     Ця програмна система має наступні винятки та обмеження:
* повний проект має бути поданий до 17 червня 2024 року;
* все фінансування розвитку має бути легальним;
* складові частини проекту повинні бути дешевими і простими;
* документація звіту повинна відповідати визнаним стандартам;
* мобільні додатки використовують обмежену функціональність веб-додатків.
     
     
     2.4 Затвердження 
     
     
     Перша версія містить такі елементи
* на стороні сервера: Обмеження доступу здійснюється шляхом створення системи аутентифікації з різними рівнями для різних категорій користувачів.  Логіка програмного забезпечення розподілена. Існує окремий шар REST-контролерів [2], які обробляють HTTP-запити від клієнтів та викликають методи сервісного рівня, що реалізують бізнес-логіку програмної системи;
* на стороні клієнта: використовує протокол HTTPS і отримує дані від сервера через REST API, описаний вище. Інтерфейс програмної системи підтримує інтернаціоналізацію та локалізацію. Мова інтерфейсу може бути змінена між англійською та українською. Підтримуються різні розміри та типи екранів;
* на стороні Smart Device частини: пристрої IoT будуть мати «міст» що дозволить реалізувати передачу даних на сервер для подальших обробок даних з датчиків безпосередньо на стороні сервера чи на клієнтській частині. Можна використовувати Arduino UNO чи NANO для реалізації даних можливостей. Можливе використання Arduino з WiFi (ESP8266/ESP32);
* мобільні додатки: користувачі мобільних додатків мають систему реєстрації та автентифікації для перевірки даних. Мобільний додаток також отримує дані з сервера за допомогою REST API через HTTPS. Додаток має локалізований інтерфейс, який можна перемикати між двома мовами - українською та англійською. Мобільний додаток дозволяє користувачам перевіряти температуру та вологість контейнера, розміщувати замовлення на зберігання та підтверджувати замовлення.

3 АРХІТЕКТУРА ПРОГРАМНИХ СИСТЕМ ТА ПРОГРАМНИХ ДОДАТКІВ
     3.1 Проектування сервера застосунку
     
     
     Серверна частина додатку використовує фреймворк Spring, мова програмування Java [3]. Архітектура базується на MVC (Model-View-Controller), сервер використовує протокол HTTPS та формат передачі даних JSON для взаємодії з СУБД [4]. Реалізовано систему ієрархії шляхів, де основним шляхом для всіх шляхів є «/api».
     Логічні виклики проміжного програмного забезпечення та класи фільтрів JWT використовуються для зв'язку з сервером та обробки запитів.  Шифрованны паролі використовуються для аутентифікації та авторизації користувачів за допомогою криптографії. Дані для автентифікації користувача отримуються за допомогою POST-запиту, після чого відбувається підтвердження присутності користувача в системі, розшифровка пароля та перевірка особи, і користувач отримує JWToken [5], який дозволяє йому увійти в систему.
     У ході роботи ми проаналізували тему та визначили основні типи використання веб-клієнтів та мобільних додатків. Перед серверною реалізацією було створено діаграму Use-Case, яка описувала сценарії поведінки системи в процесі взаємодії з користувачем.
     Під час виконання завдання було створено схему БД [6]. Всі необхідні entities та їх атрибути були описані в першій нормальній формі, схема була перетворена до другої нормальної форми та нормалізована до третьої нормальної форми, над якою вже розпочато роботу.
     Сутності, створені в рамках нормалізіції з перекладом:
* user;
* authority;
* product;
* ordering;
* storage.
    Результатом виконання цього завдання є п'ять сутностей з атрибутами, які зображені на ER -моделі даних (Рисунок 3.1).


Рисунок 3.1 - Реляційна модель сутностей даних сервера (Entity-Relationship Model)

     Ця діаграма показує можливі взаємодії між користувачем і програмною системою. На ній описані можливі дії та визначено функції, які необхідно розробити. Діаграма варіантів використання була розроблена в кілька етапів. Спочатку були визначені основні функції програмного продукту, потім ці функції були розділені на підфункції і створена діаграма можливих дій користувача.
      Перехід від функцій до діаграм створив різні типи зв'язків між елементами системи (див. рис. 3.2).

Рисунок 3.2 - Діаграма прецедентів серверної частини (Use case)

     Діаграма розгортання була розділена на вузли та компоненти, а також визначені протоколи обміну інформацією між ними. На основі цього розбиття була створена схема розподілу, що складається з наступних вузлів:
* сервер бази даних;
* веб-сервер;
* сервери додатків;
* персональний комп'ютер;
* розумні програми;
* мобільні пристрої.
     Розроблена Deployment diagram показана на рисунку 3.3.
     

Рисунок 3.3 - Діаграма розгортання серверної частини (Deployment diagram)

     Проаналізувавши структуру моделі програмної системи, вдалося визначити пакети, з яких складається система. Ці пакети та взаємозв'язки між ними показані на діаграмі пакетів (див. рис. 3.4).


Рисунок 3.4 - Діаграма пакетів на стороні сервера (Package Diagram)
     Бізнес-логіка застосунку реалізована шляхом збору інформації про замовлення, що дозволяє менеджеру з продажів визначати популярність товарів. Наприклад, якщо меблі є популярним товаром на складі, можна замовити рекламу для цього складу на сайті з продажу меблів, що призведе до нового притоку клієнтів. Код програми для запиту на збір даних:
      1 @Query(value ="Select summa, size, type_of_product, storage_life,"+
      2    " quantity, product_id From product  Order By" +
      3    " product.size, product.summa Desc", nativeQuery = true)
      4 @Transactional
      5 ArrayList getAnalise1ByArrayList();
      6 @Query(value ="Select sum(summa) as summa, size, sum(quantity) " +
      7 "From product  Group By size Order By summa Desc",nativeQuery =true)
      8 @Transactional
      9 ArrayList getAnalise2ByArrayList();
      10 @Query(value = "Select sum(summa) as summa, type_of_product," +
      11   "sum(quantity) From product  Group By type_of_product Order By"+
      12   "summa Desc", nativeQuery = true)
      13 @Transactional
      14 ArrayList getAnalise3ByArrayList();

     Завдяки цьому можна робити висновки, які комірки мають бути на складі, що зробило б програмну систему більш бізнес-ефективною. Наприклад, якщо 10% з 33 клітин - XL, економічно вигідніше замінити їх на інші, більш популярні типи клітин.


     3.2 Проектування web-додатку
     
     
     Кожна сторінка веб-додатку - це окремий модуль, що містить файли HTML, CSS та JS [7]. Під час обміну даними з сервером використовуються протоколи HTTP та формат передачі даних JSON. 
     Перед реалізацією front-end частини ми проаналізували задачу та визначили основні можливості використання клієнтського веб-додатку.
     Система локалізована англійською та українською мовами. Це можна змінити, натиснувши на відповідну назву в меню в правому верхньому куті. Спосіб локалізації полягає в наступному:
      1  $(function() {
      2      $('.translate').click(function() {
      3          var lang = $(this).attr('id');
      4    
      5          $('.lang').each(function(index, item) {
      6              $(this).text(arrLang[lang][$(this).attr('key')]);
      7          });
      8      });
      9    });
     
     Ця частина проєкту складається з різних типів учасників: клієнтів, які хочуть розміщувати замовлення, та адміністраторів, які можуть переглядати статистику товарів, перевіряти температуру і вологість на складі, змінювати замовлення, додавати і видаляти складські комірки. Клієнти можуть переглядати та змінювати свої облікові записи, розміщувати замовлення та визначати дані для управління складом.
     В процесі проектування була створена діаграма компонентів web-клієнту, щоб візуалізувати роботу клієнтських компонентів системи та показати їх взаємодію і логіку технічного проектування.
     На рисунку 3.5 показані компоненти, що використовуються для автоматизації зберігання товарів на складі.
	Діаграма станів станів (State Diagram) була створена для більш детального опису динамічних аспектів поведінки системи та користувача в контексті програми та наведена у додатку А.


Рисунок 3.5 - Схема компонентів WEB-додатку

     Через відповідні REST-запити від компонентів здійснюється безпосередньо взаємодія з серверною частиною, яка потребує певних даних. Приклади таких запитів можна знайти у Додатку Б.
     
     
     3.3 Розробка мобільної частини
     
     
     Мобільний застосунок розроблено з використанням платформи Android Studio та мови Java [8]. Архітектура базується на MVC (Model View Controller). Під час обміну даними з сервером використовуються протоколи HTTP та формат передачі даних JSON.
     Перед реалізацією мобільного додатку ми проаналізували запити, визначили всі основні варіанти використання мобільного додатку та створили діаграму варіантів використання, що описує сценарії поведінки додатку в процесі взаємодії з користувачем.
     На рисунку 3.6 показано Use case діаграму для мобільного додатку.

Рисунок 3.6 – Діаграма прецедентів мобільного застосунку (Use case)

     У мобільних ІТ-додатках є лише один ключовий гравець: клієнт.
     Клієнти можуть переглянути дані свого рахунку, оформити замовлення, отримати всю інформацію, пов'язану із замовленням, а також перевірити температуру і вологість контейнера.
     В процесі проектування була створена діаграма компонентів програмної системи мобільного додатку, яка дозволяє візуалізувати поведінку компонентів системи на стороні клієнта та показати їх взаємодію і логіку технічного рішення. Діаграма компонентів програмної системи зображена на рисунку 3.7.


Рисунок 3.7 - Схема компонентів мобільного додатку

     Діаграма станів (State Diagram), що наведена у додатку В, була створена для більш детального опису динамічних аспектів системи та поведінки користувача в програмній системі. 
     Так як мобільні додатки на платформі Android реалізуються за допомогою об'єктно-орієнтованої мови програмування Java, то всі компоненти мобільного додатку реалізовані у вигляді класів-активностей, класів-помічників та класів-тегів, які реалізовані у вигляді класів-макетів. Приклад програмного рішення для виведення інформації наведено в додатку Г.


     
     
     
     
     
     
     
     
     
     
    
4 ОПИС РОЗРОБЛЕНОЇ ПРОГРАМНОЇ СИСТЕМИ
     4.1 Підключення до веб-додатків та їх інтерфейс
     
     
     Після відкриття веб-додатку користувач буде перенаправлений на форму автентифікації (див. Рисунок 4.1).


Рисунок 4.1 - Форма логіну у веб-додатку

     У випадку, коли клієнт ще не має облікового запису, натискання кнопки "Зареєструватися" перенаправить його на сторінку реєстрації, де він заповнить реєстраційні поля і натисне кнопку "Зареєструватися" (див. Рисунок 4.2).

Рисунок 4.2 - Реєстраційна форма для веб-додатку

     Після продовження користувача буде перенаправлено на сторінку входу в систему. Тільки після того, як ви пройдете валідацію та аутентифікацію, користувача буде перенаправлено на головну сторінку сайту (див. Рисунок 4.3).
     Основні елементи веб-сайту:
* замовити;
* користувачі;
* список мої замовлень;
* мій акаунт;
* товари;
* статистика;
* замовлення;
* сховище.

Рисунок 4.3 - Головна сторінка клієнтської частини

     Треба натиснути на кнопку "Замовити", щоб відкрити форму замовлення. Після введеня необхідних даних треба натиснути на кнопку "Замовити" (див. Рисунок 4.4).
     Після того, як замовлення створено, його потрібно додати до книги замовлень і обробити там.


Рисунок 4.4 – Форма замовлення товару

     Після натискання кнопки "Замовити" статус замовлення змінюється на "false" (див. Рис. 4.5), що означає, що це замовлення ще не оброблено адміном і має бути доставлено на склад найближчим часом.
     
     
     Рисунок 4.5 – Прийняте замовлення в ячейці на складі
     
     Для цього зареєструємося як адмін та створимо вільний склад, натиснувши на слово «Склад» у розділі «Склад» (див. Рис. 4.6).
     
     Рисунок 4.6 – Створення ячейки на складі
     
     Оберемо розмір нової ячейки та назву. Розмір нехай буде XL, а назва XL007. Після додавання маємо нову ячейку без товару (див. Рис. 4.7)
     
     
     Рисунок 4.7 – Вільна ячейка на складі
     Тепер у розділі «Замовлення» натиснемо на кнопку «Прийняти замовлення» і побачимо, що статус замовлення змінився на true (див. Рис 4.8).
     
     
     Рисунок 4.8 – Прийняте замовлення
     
     У розділі «Склад» тепер можемо бачити, що прийняте замовлення перенесено на склад з ячейкою XL007 (див. Рис 4.9). Дані про товар також відображені в ячейці.
     
     Рисунок 4.9 – Прийняте замовлення в ячейці на складі

     Натисніть на кнопку "Мої замовлення", щоб переглянути всі товари на складі (див. Малюнок 4.10).


Рисунок 4.10 – Перегляд усіх замовлень користувача

     Натиснувши на кнопку "Мій обліковий запис", ви потрапите на сторінку вашого профілю, де зможете змінити свої особисті дані (див. Малюнок 4.11).


Рисунок 4.11 – Профіль користувачп для веб-додаткe

Веб-додаток локалізовано англійською та українською мовами. Для цього натисніть кнопку "UA" або "ENG", і мова зміниться на відповідній вкладці (див. Рис. 4.12 та див. Рис. 4.13).


Рисунок 4.12 – Сторінка товарів українською



Рисунок 4.13 – Сторінка товарів англійською

     Веб-додаток дозволяє адміну переглядати інформацію про товари на складах. Це робиться натисканням на кнопку "Продукт", яка відкриває сторінку з оглядом продуктів на складі (див. рис. 4.14). Адмін оновлювати інформацію про температуру та вологість в ячейках за допомогою IoT девайсів, отримавши показники з датчиків за допомогою кнопки вгорі сторінки, або ж може змінювати цю інформацію про зберігання вручну у випадку, коли датчики мають дефектні дані.


Рисунок 4.14 – Перелік продуктів веб-додатків

     Якщо натиснути на один зі стовпчиків, з'явиться форма з полями для зміни температури і вологості (див. Рисунок 4.15).
     

Рисунок 4.15 - Форма зміни температури та вологості у веб-додатку

Якщо натиснути на кнопку оновлення даних з датчиків, то дані оновляться автоматично для кожного продукту, що розміщений на складу. В залежності від кольорів, адмін може зрозуміти, які продукти мають належні умови зберігання (зелений), які мають незначні порушення (жовтий), які мають серйозні відхилення (червоний), та які мають критичні відхилення (чорний) (див. Рисунок 4.16).


Рисунок 4.16 – Результат отримання даних з датчиків по складам

     Натиснувши на кнопку "Статистика", ви також побачите три типи статистики (див. Рисунок 4.17).
     


Рисунок 4.17 – Статистика по складам та продуктам у веб-додатку
     Статистика під номером три групує загальну вартість, тип продукту та загальну кількість за типом продукту, від найбільшої вартості до найменшої.
     Друга статистика базується на загальній кількості, розмірі та обсязі товарів, згрупованих за розміром, від найбільшого до найменшого обсягу.
     Перша статистика показує загальну вартість, розмір, тип товару, дату останнього запису, кількість товару та ідентифікатор товару, відсортовані від більшого до меншого за розміром та вартістю товару.
     
     
     4.2 Інтерфейс для мобільних додатків
     
     
     Після запуску мобільного додатку користувач перенаправляється на сторінку входу в систему (див. Рис. 4.18).
     

Рисунок 4.18 – Сторінка автентифікації мобільного додатку

     Якщо клієнт ще не має облікового запису, натискання кнопки "Зареєструватися" перенаправить його на реєстраційну форму, де він повинен заповнити реєстраційні поля і натиснути кнопку "Зареєструватися" (див. Рисунок 4.19).


Рисунок 4.19 – Реєстраційна форма для мобільних додатків

     Вас буде перенаправлено на сторінку входу в систему. Після того, як ви правильно введете всі дані, вас буде перенаправлено на головну сторінку мобільного додатку (див. Рис. 4.20).

Рисунок 4.20 – Головна сторінка мобільного додатку

     Натиснувши на кнопку "Замовити", ви потрапите на сторінку замовлення товару. Після заповнення всіх полів натисніть на кнопку "Оплатити" (див. Малюнок 4.21).
      Замовлення потім повинно бути прийняте адміном.


Рисунок 4.21 – Сторінка створення замовлення

     Всі замовлення можна переглянути на сторінці "Мої замовлення".
     Натисніть на кнопку "Мої замовлення", щоб відкрити відповідну сторінку (див. Рис. 4.22).




Рисунок 4.22 – Сторінка "Мої замовлення" в мобільному додатку

	Тепер приймемо замовлення через адміна на веб-додатку та знову поглянемо на наше замовлення (див. Рисунок 4.23).


Рисунок 4.23 – Нові дані створеного замовлення після прийняття адміном

     Користувачі також можуть редагувати свій профіль, натиснувши на кнопку "Профіль".
     На сторінці "Профіль" можна змінити наступні поля (див. Рис. 4.24).
* прізвище та ім'я;
* вік;
* електронна пошта;
* номер телефона.


Рисунок 4.24 – Профіль користувача мобільного додатку

     Мобільний додаток локалізовано англійською та українською мовами. Мобільний додаток запускається тією ж мовою, що і телефонна система. Щоб змінити мову мобільного додатку, виберіть Налаштування телефону, Телефонна система, Мова і введення, Мови і виберіть потрібну мову. Мова зміниться відповідно до обраної мови (див. Рис. 4.25). Також є можливість змінити мову вручну за допомогою кнопки вгорі при вході в систему.


Рисунок 4.25 – Демонстрація реалізації локалізації

     На сторінці "Статистика" ви можете переглянути статистику замовлень, натиснувши на кнопку "Статистика" (див. Рис. 4.26).


Рисунок 4.26 – Статистика замовлень у мобільному додатку

     Відкриється нове вікно, в якому ми можемо ознайомитися зі "Статистикою 1" чи "Статистикою 2", обравши ту, що нас цікавить, зі списку.




ВИСНОВКИ


     Під час роботи над курсовим проєктом було створено програмну систему для автоматизації зберігання товарів на "інтелектуальному складі". Система була розроблена з урахуванням специфікації системних вимог, використанням бази даних PostgreSQL, мови програмування Java, фреймворку Spring, Android Studio для мобільної розробки та редактору коду IntelliJ IDEA.
     Тестові середовища були створені для компонентів ІТ-систем, включаючи серверні та веб-додатки, доступ до яких здійснюється через інтерфейси прикладного програмування (API), а також мобільні додатки, що взаємодіють з API.
     Система дозволятиме компанії побудувати міцні та вигідні взаємовідносини з клієнтами, суттєво підвищити ефективність роботи та керувати процесами в режимі реального часу.
     Під час розробки проекту були застосовані ключові методи, програмний код був переглянутий, щоб зробити його більш зрозумілим для програмістів, а програмну систему стало легше підтримувати і розширювати.
     Майбутня версія прискорить обробку замовлень і розширить функції адміністратора.










ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ


     1. Startpack URL: https://startpack.ru/compare/my-sklad/price-matrix/ (дата звернення: 04.04.2024).
     2. Керівництво по Spring URL: https://proselyte.net/tutorials/spring-tutorial-full-version/ (дата звернення: 16.04.2024).
     3. Джошуа Блох. Java. Эффективное программирование /М.: Лори, 2016. – 440 с. (дата звернення: 19.04.2024).
     4. Документація по PostgreSQL 9.4.1 /URL: https://postgrespro.ru/docs/postgresql/9.4/reference (дата звернення: 21.04.2024).
     5. The Java Tutorials URL: https://docs.oracle.com/javase/tutorial (дата звернення: 03.05.2024).
     6. Крис Дейт. Введение в системы баз данных / М.: Диалектика, 2016. 1328 с. (дата звернення: 04.05.2024).
     7. Керівництво JavaScript URL: https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide (дата звернення: 29.05.2024).
     8. Керівництво по Android Studio URL: https://android.inform.click/ (дата звернення: 13.05.2024).
     9. Герберт Шилдт, Java. Полное руководство. 10-е издание /М.: Диалектика, 2019. – 1488 с. (дата звернення: 04.05.2024).
     10. Мартин Фаулер. Рефакторинг. Улучшение существующего кода /СПб: Символ-Плюс, 2015. – 378 с. (дата звернення: 15.05.2024).
     11. Звіти у сфері науки і техніки. Структура та правила оформлювання. ДСТУ 3008:2015/ URL: http://www.knmu.kharkov.ua/attachments/3659_3008-2015.PDF (дата звернення: 02.06.2024).



ДОДАТОК А
Діаграма станів веб-додатку



Рисунок A.1 – Діаграма станів веб-додатку












ДОДАТОК Б
Програмний код веб-додатку


1 const addProductURL = 'http://localhost:25016/api/addProduct';
2 const getProductIdURL = 'http://localhost:25016/api/getProductId';
3 const addOrderingURL = 'http://localhost:25016/api/addOrdering';
4 const backupDB = 'http://localhost:25016/api/backupDB';
5 const restoreDB = 'http://localhost:25016/api/restoreDB';
6 
7 let token = sessionStorage.getItem('id_token');
8 let user = JSON.parse(sessionStorage.getItem('user'));
9 console.log(user);
10 let productId;
11 let sum;
12 
13 let copyButton = document.querySelector('#copy');
14 let restoreButton = document.querySelector('#restore');
15 
16 copyButton.addEventListener('click', copyDataBase);
17 
18 function copyDataBase() {
19     let xhr = new XMLHttpRequest();
20     xhr.open('GET', backupDB, true);
21     xhr.setRequestHeader('Authorization', 'Bearer ' + token);
22     xhr.setRequestHeader('Content-type','application/json; charset=utf-8');
23     xhr.send();
24     xhr.onreadystatechange = () => {
25         console.log('success');
26         if(xhr.readyState == 4) {
27             alert('База даних успішно скопійована!');
28         }
29     };
30 }
31 
32 restoreButton.addEventListener('click', restoreDataBase);
33 
34 function restoreDataBase() {
35     let xhr = new XMLHttpRequest();
36     xhr.open('POST', restoreDB, true);
37     xhr.setRequestHeader('Authorization', 'Bearer ' + token);
38     xhr.setRequestHeader('Content-type','application/json; charset=utf-8');
39     xhr.send();
40     xhr.onreadystatechange = () => {
41         console.log('success');
42         if(xhr.readyState == 4) {
43             alert('База даних успішно відновлена!');
44             document.location.href = '../main.html';
45         }
46     };
47 }
48 
49 //Modal
50 let orderModalButton = document.querySelector('#order-modal');
51 let modalWindow = document.querySelector('.modal');
52 let cancelButton = document.getElementById('cancel');
53 let orderButton = document.getElementById('order');
54 orderModalButton.addEventListener('click', () => {
55     modalWindow.classList.remove('invisible');
56     modalWindow.style.display = 'flex';
57 });
58 cancelButton.addEventListener('click', () => {
59     modalWindow.classList.add('invisible');
60     modalWindow.style.display = 'none';
61 });
62 
63 //Inputs
64 let weight = document.getElementById('weight');
65 let size = document.getElementById('size');
66 let typeOfProduct = document.getElementById('typeOfProduct');
67 let quantity = document.getElementById('quantity');
68 let storageLife = document.getElementById('storageLife');
69 let temperatureRange = document.getElementById('temperatureRange');
70 let humidityRange = document.getElementById('humidityRange');
71 
72 let total = document.querySelector('.total__sum_money');
73 
74 orderButton.addEventListener('click', sendOrder);
75 quantity.addEventListener('change', () => {
76     let today = new Date();
77     let deadLine = new Date(storageLife.value);
78     let difference = getDays(today, deadLine);
79     sum = countTotalSum(difference, size.value, quantity.value, weight.value);
80     total.innerHTML = sum;
81     console.log(difference);
82     console.log(size.value);
83     console.log(quantity.value);
84     console.log(sum);
85 });
86 weight.addEventListener('change', () => {
87     let today = new Date();
88     let deadLine = new Date(storageLife.value);
89     let difference = getDays(today, deadLine);
90     sum = countTotalSum(difference, size.value, quantity.value, weight.value);
91     total.innerHTML = sum;
92     console.log(difference);
93     console.log(size.value);
94     console.log(quantity.value);
95     console.log(sum);
96 });
97 size.addEventListener('change', () => {
98     if(size.value === "m" || size.value === "М" || size.value === "м") {
99         size.value = "M";
100     } else if(size.value === "l" || size.value === "Л" || size.value === "л") {
101         size.value = "L";
102     } else if(size.value === "xl" || size.value === "ХЛ" || size.value === "хл") {
103         size.value = "XL";
104     }
105     let today = new Date();
106     let deadLine = new Date(storageLife.value);
107     let difference = getDays(today, deadLine);
108     sum = countTotalSum(difference, size.value, quantity.value, weight.value);
109     total.innerHTML = sum;
110     console.log(difference);
111     console.log(size.value);
112     console.log(quantity.value);
113     console.log(sum);
114 });
115 storageLife.addEventListener('change', () => {
116         let today = new Date();
117         let deadLine = new Date(storageLife.value);
118         let difference = getDays(today, deadLine);
119         sum = countTotalSum(difference, size.value, quantity.value, weight.value);
120         total.innerHTML = sum;
121         console.log(difference);
122         console.log(size.value);
123         console.log(quantity.value);
124         console.log(sum);
125 });
126 
127 function sendOrder() {
128     let data = {};
129     if(new Date(storageLife.value) < new Date()) {
130         alert('Дата не може бути меншою за сьогоднішню! Поставлена сьогоднішня!');
131         sum = countTotalSum(difference, size.value, quantity.value, weight.value);
132         total.innerHTML = sum;
133     }
134     
135     data.weight = `${weight.value} кг`;
136     data.size = size.value;
137     data.typeOfProduct = typeOfProduct.value;
138     data.quantity = quantity.value;
139     data.temperatureRange = `${temperatureRange.value} C`;
140     data.humidityRange = `${humidityRange.value}%`;
141     data.summa = total.innerHTML;
142     data.customerId = user.id;
143 
144     let dataToJSON = JSON.stringify(data);
145     console.log(dataToJSON);
146     let xhr = new XMLHttpRequest();
147     xhr.open('POST', addProductURL, true);
148     xhr.setRequestHeader('Authorization', 'Bearer ' + token);
149     console.log('Bearer ' + token);
150     xhr.setRequestHeader('Content-type','application/json; charset=utf-8');
151     xhr.send(dataToJSON);
152     xhr.onreadystatechange = () => {
153         if (xhr.readyState == 4) {
154             if (xhr.status == 201) {
155                 let answer = JSON.parse(xhr.responseText);
156                 productId = answer.productId;
157                 console.log('productId: ' + answer.productId);
158                 addOrdering();
159                 console.log('success IN ADDING PRODUCT');
160             } else {
161                 console.log('Error in adding product: ' + xhr.responseText);
162             }
163         }
164     };
165 }
166 
167 
168 function addOrdering() {
169     let today = new Date();
170     let data = {};
171     data.date = `${transformDate(today)}`;
172     data.productId = productId;
173     data.status = false;
174     data.sum = `${sum}`;
175     data.size = size.value;
176 
177     let dataToJSON = JSON.stringify(data);
178 
179     let xhr = new XMLHttpRequest();
180     xhr.open('POST', addOrderingURL, true);
181     xhr.setRequestHeader('Authorization', 'Bearer ' + token);
182     xhr.setRequestHeader('Content-type','application/json; charset=utf-8');
183     xhr.send(dataToJSON);
184     xhr.onreadystatechange = () => {
185         console.log('success');
186         if(xhr.readyState == 4) {
187             let answer = JSON.parse(xhr.responseText);
188             console.log(answer);
189             document.location.href = './welcomePage.html';
190         }
191     };
192 }
193 
194 function getDays(today, deadLine) {
195     let t1 = deadLine.getTime();
196     let t2 = today.getTime();
197     return parseInt((t1-t2)/(24*3600*1000))+1;
198 }
199 
200 function countTotalSum(difference, size, quantity, weight) {
201     switch(size) {
202         case "M":
203             return Math.round(difference * (20 + weight * 0.1) * quantity)
204         case "L":
205             return Math.round(difference * (25 + weight * 0.08) * quantity)
206         case "XL":
207             return Math.round(difference * (30 + weight * 0.05) * quantity)
208         default:
209             return;
210     }
211 }
212 
213 function transformDate(today) {
214     let day = today.getDate();
215     let month = today.getMonth()+1;
216     let year = today.getFullYear();
217     if(day < 10) day = `0${day}`
218     if(month < 10) month = `0${month}`
219     return `${day}.${month}.${year}`;
220 }
221 
222 document.addEventListener('DOMContentLoaded', getLocalLang);
223 
224 let arrLang = {
225     'en': {
226         'cancel': 'Cancel',
227         'order': 'Order',
228         'total__sum': 'Total sum',
229         'storageLife': 'Storage life',
230         'temperatureRange': 'Temperature range',
231         'humidityRange': 'Humidity range',
232         'size': 'Size',
233         'typeOfProduct': 'Type of product',
234         'quantity': 'Quantity',
235         'weight': 'Weight',
236         'exit': 'Exit',
237         'order': 'Order',
238         'myOrders': 'My Orders',
239         'myAccount': 'My Account',
240         'products': 'Products',
241         'statistic': 'Statistic',
242         'orderings': 'Orders',
243         'storages': 'Storages',
244         'welcome': 'Welcome!',
245         'backHeading': 'Welcome to',
246         'users': 'Users',
247         'copy': 'Backup DB',
248         'restore': 'Restore DB',
249         'products-title': 'Products'
250     },
251     'ua': {
252         'cancel': 'Скасувати',
253         'order': 'Замовити',
254         'total__sum': 'Загальна сума',
255         'storageLife': 'Термін зберігання',
256         'temperatureRange': 'Діапазон температур',
257         'humidityRange': 'Діапазон вологості',
258         'size': 'Розмір',
259         'typeOfProduct': 'Тип товару',
260         'quantity': 'Кількість',
261         'weight': 'Вага',
262         'exit': 'Вийти',
263         'order': 'Замовити',
264         'myOrders': 'Мої замовлення',
265         'myAccount': 'Мій акаунт',
266         'products': 'Товар',
267         'statistic': 'Статистика',
268         'orderings': 'Замовлення',
269         'storages': 'Склад',
270         'welcome': 'Вітаю!',
271         'backHeading': 'Вас вітає',
272         'users': 'Користувачі',
273         'copy': 'Копіювання БД',
274         'restore': 'Відновлення БД',
275         'products-title': 'Товар'
276     }
277   };
278   $(function() {
279     $('.translate').click(function() {
280         var lang = $(this).attr('id');
281         saveLocalLang(lang);
282 
283         $('.lang').each(function(index, item) {
284             $(this).text(arrLang[lang][$(this).attr('key')]);
285         });
286     });
287   });
288 
289 function saveLocalLang(language) {
290     let langs;
291     if(localStorage.getItem('langs') === null) {
292         langs = [];
293     } else {
294         langs = JSON.parse(localStorage.getItem('langs'));
295     }
296     langs.push(language);
297     localStorage.setItem('langs', JSON.stringify(langs));
298 }
299 
300 function getLocalLang(language) {
301     let langs;
302     if(localStorage.getItem('langs') === null) {
303         langs = [];
304     } else {
305         langs = JSON.parse(localStorage.getItem('langs'));
306     }
307     langs.forEach(function (language) {
308         let lang = langs[langs.length - 1];
309         $('.lang').each(function(index, item) {
310             $(this).text(arrLang[lang][$(this).attr('key')]);
311         });
312     });
313 }



ДОДАТОК В
Діаграма станів мобільного додатку 



Рисунок В.1 – Діаграма станів мобільного додатку










ДОДАТОК Г
Код програми мобільного додатку


1 package com.example.smartstoragemobile;
2 
3 import android.content.DialogInterface;
4 import android.content.Intent;
5 import android.content.SharedPreferences;
6 import android.content.res.Configuration;
7 import android.content.res.Resources;
8 import android.os.Bundle;
9 import android.preference.PreferenceManager;
10 import android.text.TextUtils;
11 import android.view.LayoutInflater;
12 import android.view.Menu;
13 import android.view.MenuItem;
14 import android.view.View;
15 import android.widget.Button;
16 import android.widget.RelativeLayout;
17 import android.widget.Toast;
18 
19 import androidx.appcompat.app.AlertDialog;
20 import androidx.appcompat.app.AppCompatActivity;
21 
22 import com.android.volley.Request;
23 import com.android.volley.RequestQueue;
24 import com.android.volley.Response;
25 import com.android.volley.VolleyError;
26 import com.android.volley.toolbox.JsonObjectRequest;
27 import com.android.volley.toolbox.Volley;
28 import com.google.android.material.snackbar.Snackbar;
29 import com.rengwuxian.materialedittext.MaterialEditText;
30 
31 import org.json.JSONException;
32 import org.json.JSONObject;
33 
34 import java.util.HashMap;
35 import java.util.Locale;
36 import java.util.Map;
37 
38 public class MainActivity extends AppCompatActivity {
39     private RelativeLayout root;
40     private static final String urlRegister = "http://192.168.1.5:25016/api/register";
41     private static final String urlAuthenticate = "http://192.168.1.5:25016/api/authenticate";
42     private static final String urlUser = "http://192.168.1.5:25016/api/user";
43 
44     @Override
45     protected void onCreate(Bundle savedInstanceState) {
46         LanguageManager.setLanguage(this);
47         super.onCreate(savedInstanceState);
48         setContentView(R.layout.activity_main);
49         Button btnSignIn = findViewById(R.id.btnSignIn);
50         Button btnRegister = findViewById(R.id.btnRegister);
51         Button btnSwitchLanguage = findViewById(R.id.btnSwitchLanguage);
52         btnSwitchLanguage.setOnClickListener(new View.OnClickListener() {
53             @Override
54             public void onClick(View v) {
55                 LanguageManager.switchLanguage(MainActivity.this);
56                 Intent intent = getIntent();
57                 finish();
58                 startActivity(intent);
59             }
60         });
61         root = findViewById(R.id.root_element);
62 
63         btnRegister.setOnClickListener(new View.OnClickListener() {
64             @Override
65             public void onClick(View v) {
66                 showRegisterWindow();
67             }
68         });
69 
70         btnSignIn.setOnClickListener(new View.OnClickListener() {
71             @Override
72             public void onClick(View v) {
73                 showSignInWindow();
74             }
75         });
76     }
77 
78     @Override
79     public boolean onCreateOptionsMenu(Menu menu) {
80         getMenuInflater().inflate(R.menu.menu, menu);
81         return true;
82     }
83 
84     private void showSignInWindow() {
85         AlertDialog.Builder dialog = new AlertDialog.Builder(this);
86         dialog.setTitle(getResources().getString(R.string.log_in));
87         dialog.setMessage(getResources().getString(R.string.enter_your_login_information));
88         LayoutInflater inflater = LayoutInflater.from(this);
89         View sign_in_window = inflater.inflate(R.layout.sign_in_window, null);
90         dialog.setView(sign_in_window);
91 
92         final MaterialEditText username = sign_in_window.findViewById(R.id.username);
93         final MaterialEditText password = sign_in_window.findViewById(R.id.password);
94 
95         dialog.setNegativeButton(getResources().getString(R.string.cancel), new DialogInterface.OnClickListener() {
96             @Override
97             public void onClick(DialogInterface dialogInterface, int which) {
98                 dialogInterface.dismiss();
99             }
100         });
101 
102         dialog.setPositiveButton(getResources().getString(R.string.log_in), new DialogInterface.OnClickListener() {
103             @Override
104             public void onClick(DialogInterface dialogInterface, int which) {
105                 if (TextUtils.isEmpty(username.getText().toString())) {
106                     Snackbar.make(root, getResources().getString(R.string.enter_your_login), Snackbar.LENGTH_SHORT).show();
107                     return;
108                 }
109 
110                 if (password.getText().toString().length() < 5) {
111                     Snackbar.make(root, getResources().getString(R.string.please_enter_a_password_that_is_more_than_5_characters), Snackbar.LENGTH_SHORT).show();
112                     return;
113                 }
114 
115                 // Auth User
116                 getToken(username, password);
117                 User.username = username;
118                 User.password = password;
119             }
120 
121         });
122         dialog.show();
123     }
124 
125     private void showRegisterWindow() {
126         AlertDialog.Builder dialog = new AlertDialog.Builder(this);
127         dialog.setTitle(getResources().getString(R.string.registration_form));
128         dialog.setMessage(getResources().getString(R.string.please_fill_in_all_fields));
129 
130         LayoutInflater inflater = LayoutInflater.from(this);
131         View register_window = inflater.inflate(R.layout.register_window, null);
132         dialog.setView(register_window);
133 
134         final MaterialEditText email = register_window.findViewById(R.id.emailField);
135         final MaterialEditText username = register_window.findViewById(R.id.username);
136         final MaterialEditText password = register_window.findViewById(R.id.password);
137         final MaterialEditText phone = register_window.findViewById(R.id.phone);
138 
139         dialog.setNegativeButton(getResources().getString(R.string.cancel), new DialogInterface.OnClickListener() {
140             @Override
141             public void onClick(DialogInterface dialogInterface, int which) {
142                 dialogInterface.dismiss();
143             }
144         });
145 
146         dialog.setPositiveButton(getResources().getString(R.string.sign_up), new DialogInterface.OnClickListener() {
147             @Override
148             public void onClick(DialogInterface dialogInterface, int which) {
149                 if (TextUtils.isEmpty(email.getText().toString())) {
150                     Snackbar.make(root, getResources().getString(R.string.enter_mail), Snackbar.LENGTH_SHORT).show();
151                     return;
152                 }
153 
154                 if (TextUtils.isEmpty(username.getText().toString())) {
155                     Snackbar.make(root, getResources().getString(R.string.enter_login), Snackbar.LENGTH_SHORT).show();
156                     return;
157                 }
158 
159                 if (TextUtils.isEmpty(phone.getText().toString())) {
160                     Snackbar.make(root, getResources().getString(R.string.enter_your_phone_number), Snackbar.LENGTH_SHORT).show();
161                     return;
162                 }
163 
164                 if (password.getText().toString().length() < 5) {
165                     Snackbar.make(root, getResources().getString(R.string.enter_a_password_that_is_more_than_5_characters), Snackbar.LENGTH_SHORT).show();
166                     return;
167                 }
168 
169                 // Registration User
170                 registration(username, password, phone, email);
171             }
172         });
173         dialog.show();
174     }
175 
176     private void registration(MaterialEditText username, MaterialEditText password, MaterialEditText phone, MaterialEditText email) {
177         JSONObject js = new JSONObject();
178         try {
179             js.put("username", username.getText().toString());
180             js.put("email", email.getText().toString());
181             js.put("password", password.getText().toString());
182             js.put("fname", password.getText().toString());
183             js.put("phone", phone.getText().toString());
184         } catch (JSONException e) {
185             e.printStackTrace();
186         }
187 
188         JsonObjectRequest jsonObjReq = new JsonObjectRequest(
189                 Request.Method.POST, urlRegister, js,
190                 new Response.Listener<JSONObject>() {
191                     @Override
192                     public void onResponse(JSONObject response) {
193                         Toast.makeText(MainActivity.this, "Register Success", Toast.LENGTH_LONG).show();
194                     }
195                 },
196                 new Response.ErrorListener() {
197                     @Override
198                     public void onErrorResponse(VolleyError error) {
199                         error.printStackTrace();
200                         Toast.makeText(MainActivity.this, "Register Error" + error.toString(), Toast.LENGTH_LONG).show();
201                     }
202                 });
203 
204         RequestQueue requestQueue = Volley.newRequestQueue(this);
205         requestQueue.add(jsonObjReq);
206 
207     }
208 
209     private void getToken(MaterialEditText username, MaterialEditText password) {
210         JSONObject js = new JSONObject();
211 
212         try {
213             js.put("username", username.getText().toString());
214             js.put("password", password.getText().toString());
215         } catch (JSONException e) {
216             e.printStackTrace();
217         }
218 
219         JsonObjectRequest jsonObjReq = new JsonObjectRequest(Request.Method.POST, urlAuthenticate, js,
220                 new Response.Listener<JSONObject>() {
221                     @Override
222                     public void onResponse(JSONObject response) {
223                         try {
224                             User.token = response.getString("id_token");
225                             Toast.makeText(MainActivity.this, "Welcome", Toast.LENGTH_LONG).show();
226                             getData(User.token);
227                             startActivity(new Intent(MainActivity.this, MenuActivity.class));
228                             finish();
229                         } catch (JSONException e) {
230                             e.printStackTrace();
231                             Toast.makeText(MainActivity.this, "Fail" + e.toString(), Toast.LENGTH_LONG).show();
232                         }
233                     }
234                 }, new Response.ErrorListener() {
235             @Override
236             public void onErrorResponse(VolleyError error) {
237                 error.printStackTrace();
238                 Toast.makeText(MainActivity.this, "Fail" + error.toString(), Toast.LENGTH_LONG).show();
239             }
240         }) {
241         };
242 
243         RequestQueue queue = Volley.newRequestQueue(getApplicationContext());
244         queue.add(jsonObjReq);
245     }
246 
247     private void getData(String token) {
248         JsonObjectRequest json = new JsonObjectRequest(
249                 Request.Method.GET, urlUser, null,
250                 new Response.Listener<JSONObject>() {
251                     @Override
252                     public void onResponse(JSONObject response) {
253                         try {
254                             JSONObject jObj = new JSONObject(response.toString());
255                             User.id = jObj.getString("id");
256                         } catch (JSONException e) {
257                             e.printStackTrace();
258                             Toast.makeText(MainActivity.this, "Authorization Error" + e.toString(), Toast.LENGTH_LONG).show();
259                         }
260                     }
261                 },
262                 new Response.ErrorListener() {
263                     @Override
264                     public void onErrorResponse(VolleyError error) {
265                         error.printStackTrace();
266                         Toast.makeText(MainActivity.this, "Authorization Error" + error.toString(), Toast.LENGTH_LONG).show();
267                     }
268                 }) {
269 
270             @Override
271             public Map<String, String> getHeaders() {
272                 HashMap<String, String> headers = new HashMap<String, String>();
273                 headers.put("Authorization", "Bearer " + token);
274                 headers.put("Accept", "application/json; charset=UTF-8");
275                 headers.put("Content-Type", "application/json; charset=UTF-8");
276                 return headers;
277             }
278         };
279 
280         RequestQueue rq = Volley.newRequestQueue(getApplicationContext());
281         rq.add(json);
282     }
283 }





































ДОДАТОК Д
Плагіат пояснювальної записки з курсової роботи


Рисунок Д.1 – Плагіат пояснювальної записки з курсової роботи









4





